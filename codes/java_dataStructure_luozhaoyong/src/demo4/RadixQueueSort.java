package demo4;

import demo2.MyQueue;

import java.util.Arrays;

/**
 * 用队列实现基数排序
 * <p>
 * 思路：
 * 第一轮按照所有元素的个位数字为所有元素排序
 * 第二轮按照所有元素的十位数字为所有元素排序
 * 以此类推
 * 当按照数组中元素的最大位数排序之后，最终得到 1 个有序的数组
 * <p>
 * 例如数组 [5, 1, 72, 36, 101]
 * 为便于理解，想象元素空缺的位数上都是 0
 * 把数组写成如下形式
 * 排序前原始数组 [005, 001, 072, 036, 101]
 * <p>
 * 第一轮排序得到 [001, 101, 072, 005, 036]
 * 第一轮排序得到 [001, 101, 005, 036, 072]
 * 第一轮排序得到 [001, 005, 036, 072, 101]
 * 每次按照排序后，位数相同的数字，相对顺序不会改变
 * 如第一次按照个位排序后，两个个位数字 1 和 5
 * 1 在接下来的几轮排序后，总是位于 5 的前面
 * 所有排序结束后，就得到了按照数字整体大小排列的数组
 *
 * <p>
 * 具体操作：
 * 1. 为自然数 0 ~ 9 中的每个数字创建 1 个桶，总共 10 个
 * <p>
 * 2. 第一轮获取每个元素的个位数字，把元素放入与个位数字对应的桶中
 * 所有元素都入桶后，依次从桶中取出元素
 * 先去标号为 0 的桶中的第 1 个数字，再取第 2 个数字
 * 标号为 0 的桶取完之后，再从标号为 1 的桶取数字，以此类推
 * 按照上述顺序取出的数字，依次存入原数组第 0 个位置，第 1 个位置...
 * 装满原数组后，原数组就变成了一个按照个位数字排好序的数组
 * <p>
 * 3. 第二轮获取每个元素的十位数字
 * 按照第二个步骤的方法操作，得到一个按十位数字排好序的数组
 * <p>
 * 4. 重复以上步骤，直到按照最大的位数排好序
 * 整个数组就是有序的数组
 *
 * @author admin
 */
public class RadixQueueSort {
    public static void main(String[] args) {
        int[] arr = new int[]{23, 6, 189, 45, 9, 287, 56, 1, 798, 34, 65, 652, 5};
        radixSort(arr);
        System.out.println(Arrays.toString(arr));
    }

    /**
     * 基数排序方法
     * <p>
     * 时间复杂度：
     * 假设最大数的位数为 k，总共执行 k 轮比较
     * 每轮比较都遍历一次数组，时间复杂度为 n
     * 总的时间复杂度是 O(kn)
     *
     * @param arr 待排序的数组
     */
    public static void radixSort(int[] arr) {
        // 长度小于等于 1 的时候直接返回
        if (arr.length <= 1) {
            return;
        }
        // 1. 计算数组中最大数的位数
        // 定义一个临时遍历 max 用于获取数组中最大的数
        int max = Integer.MIN_VALUE;
        // 遍历数组，找到最大的数字
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        // 获取最大数字的位数
        int maxLength = (max + "").length();

        // 2. 定义存放元素的桶
        // 定义一个队列数组，数组长度为 10，表示 0~9 数字对应的 10 个桶
        // 每个桶都是一个先进先出的队列
        MyQueue[] temp = new MyQueue[10];
        // 遍历队列数组
        for (int i = 0; i < temp.length; i++) {
            // 数组中每个元素赋值为一个新的队列对象
            temp[i] = new MyQueue();
        }

        // 3. 遍历数组，按照每个元素各个位上的数字为数组进行多轮排序
        // 定义进位基数 10
        int scale = 10;

        // 数组中最大数字的位数是 maxLength，外循环总共循环 maxLength 轮
        // 另外定义一个除数 n，用来获取数字上每一位的数字
        // n 的初始值是 1，即取个位上的数
        // 每一轮结束都递乘 10，即第二轮 n = 10，获取十位上的数字，第三轮 n = 100，以此类推
        for (int i = 1, n = 1; i <= maxLength; i++, n *= scale) {
            // 内循环遍历数组
            for (int j = 0; j < arr.length; j++) {
                // 获取当前下标 j 在原数组中对应的元素
                int num = arr[j];
                // 计算元素在当前位上的余数
                // 第一轮，i=1, n = 1，((num / 1) % 10) 得到个位上的数字
                // 第二轮，i=2, n = 10，((num / 10) % 10) 得到十位上的数字
                // 依次类推
                int remainder = (num / n) % 10;
                // 通过余数 remainder 获取对应数字的桶
                MyQueue bucket = temp[remainder];
                // 将当前元素存入桶中
                bucket.add(num);
            }

            // 记录原数组的下标变化，从桶中取出元素放回原数组时，下标递增
            int index = 0;
            // 遍历队列数组
            for (int k = 0; k < temp.length; k++) {
                // 通过 k 获取对应的桶
                MyQueue bucket = temp[k];
                // 只要桶不为空，就继续遍历
                while (!bucket.isEmpty()) {
                    // 桶中的元素出列，放入原数组，同时原数组下标 index 递增
                    arr[index++] = bucket.poll();
                }
            }
            System.out.println(Arrays.toString(arr));

        }
    }

}
