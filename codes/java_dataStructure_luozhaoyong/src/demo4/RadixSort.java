package demo4;

import java.util.Arrays;

/**
 * 基数排序
 * <p>
 * 思路：
 * 第一轮按所有元素的个位数字排序
 * 第二轮按所有元素的十位数字排序
 * 以此类推
 * 当按照数组中元素的最大位数排序之后，最终得到 1 个有序的数组
 * <p>
 * 例如数组 [5, 1, 72, 36, 101]
 * 为便于理解，想象元素空缺的位数上都是 0
 * 把数组写成如下形式
 * 排序前原始数组 [005, 001, 072, 036, 101]
 * <p>
 * 第一轮按个位排序得到 [001, 101, 072, 005, 036]
 * 第二轮按十位排序得到 [001, 101, 005, 036, 072]
 * 第三轮按百位排序得到 [001, 005, 036, 072, 101]
 * 每轮排序后，位数相同的数字，相对顺序不会改变
 * 如第一次按照个位排序后，两个个位数字 1 和 5
 * 1 在接下来的几轮排序过程中，总是位于 5 的前面
 * 所有排序结束后，就得到了按照数字整体大小排列的数组
 *
 * <p>
 * 具体操作：
 * 1. 为自然数 0 ~ 9 中的每个数字创建 1 个桶，总共 10 个
 * <p>
 * 2. 第一轮获取每个元素的个位数字，把元素放入与个位数字对应的桶中
 * 所有元素都入桶后，依次从桶中取出元素
 * 先取标号为 0 的桶中的第 1 个数字，再取第 2 个数字 ...
 * 标号为 0 的桶取完之后，再从标号为 1 的桶取数字，以此类推
 * 按照上述顺序取出的数字，依次存入原数组第 0 个位置，第 1 个位置 ...
 * 装满原数组后，原数组就变成了一个按照个位数字排好序的数组
 * <p>
 * 3. 第二轮获取每个元素的十位数字
 * 按照第二个步骤的方法操作，得到一个按十位数字排好序的数组
 * <p>
 * 4. 重复以上步骤，直到按照最大的位数排好序
 * 整个数组就是有序的数组
 *
 * @author admin
 */
public class RadixSort {
    public static void main(String[] args) {
        int[] arr = new int[]{23, 6, 189, 45, 9, 287, 56, 1, 798, 34, 65, 652, 5};
        radixSort(arr);
        System.out.println(Arrays.toString(arr));
    }

    /**
     * 基数排序方法
     * <p>
     * 时间复杂度：
     * 假设最大数的位数为 k，总共执行 k 轮比较
     * 每轮比较都遍历一次数组，时间复杂度为 n
     * 总的时间复杂度是 O(kn)
     *
     * @param arr
     */
    public static void radixSort(int[] arr) {
        // 长度小于等于 1 的时候直接返回
        if (arr.length <= 1) {
            return;
        }
        // 1. 计算数组中最大数的位数
        // 定义一个临时变量 max 用于获取数组中最大的数
        int max = Integer.MIN_VALUE;
        // 遍历数组，找到最大的数字
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        // 获取最大数字的位数
        int maxLength = (max + "").length();

        // 2. 定义一个 10 行 arr.length 列的二维数组
        // 行数为 10，表示 0~9 数字对应的 10 个桶
        // 列数为 arr.length，考虑到所有元素都在同一个桶中的极端情况
        // 每个桶的容量都需要与数组的长度相等
        int[][] temp = new int[10][arr.length];

        // 定义一个用于计数的数组
        // 数组中每个元素的数值，代表对应的桶中有多少个元素
        int[] count = new int[10];

        // 3. 遍历数组，按照每个元素各个位上的数字为数组进行多轮排序
        // 定义进位基数 10
        int scale = 10;
        // 数组中最大数字的位数是 maxLength，外循环总共循环 maxLength 轮
        // 另外定义一个除数 n，用来获取数字上每一位的数字
        // n 的初始值是 1，即取个位上的数
        // 每一轮结束都递乘 10，即第二轮 n = 10，获取十位上的数字，第三轮 n = 100，以此类推
        for (int i = 0, n = 1; i < maxLength; i++, n *= scale) {

            // 内循环遍历数组
            for (int j = 0; j < arr.length; j++) {
                // 获取当前下标 j 在原数组中对应的元素
                int num = arr[j];
                // 计算元素在当前位上的余数
                // 第一轮，i=1, n = 1，((num / 1) % 10) 得到个位上的数字
                // 第二轮，i=2, n = 10，((num / 10) % 10) 得到十位上的数字
                // 以此类推
                int remainder = (num / n) % 10;

                // 通过余数 remainder 获取对应数字的桶 temp[remainder]
                // 向桶中添加当前元素，同时桶对应的计数器 count[remainder] 递增
                temp[remainder][count[remainder]++] = num;
            }

            // 记录原数组的下标变化，从桶中取出元素放回原数组时，下标递增
            int index = 0;
            // 遍历计数器数组
            for (int k = 0; k < count.length; k++) {
                // 获取 k 值对应的桶中有多少个元素
                int volume = count[k];
                // 只要计数器不为 0，说明桶中还有元素
                if (volume > 0) {
                    // 获取 k 值对应的桶
                    int[] bucket = temp[k];
                    // 桶内有 volume 个元素，则 l 正好对应下标 0 ~ volume-1
                    for (int l = 0; l < volume; l++) {
                        // 通过下标 l 获取桶内的元素 bucket[l]
                        // 将桶内元素 bucket[l] 赋值给原数组相应的位置
                        arr[index++] = bucket[l];
                        // index++ 指针指向下一个位置
                    }
                    // 循环结束后，将当前桶的计数器清零
                    count[k] = 0;
                }
            }
        }
    }

}
