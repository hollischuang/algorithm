class Solution {//这道题虽然不难，但在解决的过程中会发现有更优质的方法去解决
   public int[] twoSum(int[] nums, int target) {//第一眼看到这个题的时候，很像冒泡排除，选择排序
		           int i=0; int j=i+1;//其实这个效率低的方法直接冒泡就可以
		        for(i=0;i<nums.length-1;i++){ // 确定要循环几次，来走完所有的情况
		            for(j=i+1;j<nums.length;j++){//确定在上面定义的每一次循环中遍历所有的情况
		                if(nums[i]+nums[j]==target) {//进行比对，更优质的应该是二维数组，考虑有多个值的情况
		                    return new int[] {i,j};
		                 }	
		             }		  		          
	              } 	
	            return new int[] {i,j};
     }//当你做完这道题，会发现如果我用map，以健值对的形式放进去，所以你就将下标作为键，值作为value
// 但是后面你会发现，无法根据值来获得键的位置，所以当时应该吧值作为键，下标作为值可以解决
//     个人认为还是有缺点的例如：加入有多种情况是值是重复的呢？

 }
